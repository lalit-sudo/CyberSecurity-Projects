import os
import time
import hashlib
import shutil
import subprocess
import threading
from queue import Queue

# Banner
def print_banner():
    banner = """
    ==========================================
    |            MALWAREWATCHDOG            |
    |     __  __       _                     |
    |    |  \/  |     | |                    |
    |    | \  / | __ _| |_ ___  _ __         |
    |    | |\/| |/ _` | __/ _ \| '_ \        |
    |    | |  | | (_| | || (_) | | | |       |
    |    |_|  |_|\__,_|\__\___/|_| |_|       |
    |                                       |
    |   Developed By: Lalit Kumar            |
    |                                       |
    |   A basic malware detection tool       |
    |   that scans files and folders for     |
    |   known malware signatures. It allows  |
    |   you to quarantine or remove detected |
    |   files and provides detailed reports. |
    ==========================================
    """
    print(banner)

# Load malware signatures from a local file
def load_signatures(file_path='signatures.txt'):
    if not os.path.isfile(file_path):
        raise FileNotFoundError(f"Signatures file not found: {file_path}")
    with open(file_path, 'r') as file:
        signatures = file.read().splitlines()
    print(f"Loaded {len(signatures)} signatures")
    return set(signatures)

# Get file hash
def get_file_hash(file_path):
    if not os.path.isfile(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")
    hasher = hashlib.md5()
    with open(file_path, 'rb') as file:
        buf = file.read()
        hasher.update(buf)
    file_hash = hasher.hexdigest()
    print(f"Calculated MD5 for {file_path}: {file_hash}")
    return file_hash

# Check file against signatures
def check_file(file_path, signatures):
    try:
        file_hash = get_file_hash(file_path)
        match = file_hash in signatures
        print(f"Hash match for {file_path}: {match}")
        return match
    except FileNotFoundError:
        return False

# Get file properties
def get_file_properties(file_path):
    try:
        stats = os.stat(file_path)
        properties = {
            "path": file_path,
            "size": stats.st_size,
            "creation_time": time.ctime(stats.st_ctime),
            "modification_time": time.ctime(stats.st_mtime),
        }
        return properties
    except Exception as e:
        print(f"Error getting properties for {file_path}: {e}")
        return None

# Scan directory
def scan_directory(directory, q):
    for root, _, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(root, file)
            q.put(file_path)

# Get directory tree
def get_directory_tree(start_path="/"):
    result = subprocess.run(["tree", "-fi", start_path], capture_output=True, text=True)
    if result.returncode == 0:
        return result.stdout.splitlines()
    else:
        print("Error executing tree command.")
        return []

# Scan system
def scan_system(q):
    files_to_scan = get_directory_tree("/")
    for file_path in files_to_scan:
        q.put(file_path)

# Remove file
def remove_file(file_path):
    try:
        os.remove(file_path)
        print(f"Removed {file_path}")
    except OSError as e:
        print(f"Error: {e.filename} - {e.strerror}")

# Quarantine file
def quarantine_file(file_path, quarantine_dir="quarantine"):
    if not os.path.exists(quarantine_dir):
        os.makedirs(quarantine_dir)
    shutil.move(file_path, quarantine_dir)
    print(f"Quarantined {file_path}")

# Worker function for threading
def worker(q, signatures, verbose):
    while True:
        file_path = q.get()
        if file_path is None:
            break
        if verbose:
            print(f"Scanning {file_path}")
        try:
            if check_file(file_path, signatures):
                properties = get_file_properties(file_path)
                print(f"Malware detected: {properties}")
                user_input = input(f"Do you want to delete this file {file_path}? (yes/no): ").strip().lower()
                if user_input == "yes":
                    remove_file(file_path)
                else:
                    quarantine_file(file_path)
        except FileNotFoundError:
            print(f"File not found during scan: {file_path}")
        except Exception as e:
            print(f"Error processing file {file_path}: {e}")
        q.task_done()

# Get user input
def get_user_input():
    print("Choose an option:")
    print("1. Scan a specific folder")
    print("2. Scan a specific file")
    print("3. Scan the entire system")
    choice = input("Enter your choice (1/2/3): ").strip()
    return choice

# Get scan path based on user input
def get_scan_path(choice):
    if choice == '1':
        return input("Enter the path of the folder to scan: ").strip()
    elif choice == '2':
        return input("Enter the path of the file to scan: ").strip()
    elif choice == '3':
        return None
    else:
        print("Invalid choice. Exiting.")
        exit()

# Main function
def main():
    print_banner()

    choice = get_user_input()
    scan_path = get_scan_path(choice)

    signatures = load_signatures()
    detected_files = []
    verbose = input("Enable verbose mode? (yes/no): ").strip().lower() == "yes"
    
    q = Queue()
    threads = []

    if choice == '3':  # Full system scan
        scan_system(q)
    elif os.path.isfile(scan_path):
        q.put(scan_path)
    else:
        scan_directory(scan_path, q)

    for _ in range(4):  # Number of threads
        t = threading.Thread(target=worker, args=(q, signatures, verbose))
        t.start()
        threads.append(t)

    q.join()

    for _ in range(4):
        q.put(None)  # Stop signal for threads

    for t in threads:
        t.join()

if __name__ == "__main__":
    main()
